#!/usr/local/bin/python3.8

import subprocess
import collections

DEBUG = False

def run(*cmd):
  if DEBUG:
    print(cmd)
  else:
    result = subprocess.run(list(cmd), stdout=subprocess.PIPE)
    return result.stdout.decode('utf-8')


CURRENT = run('git', 'branch', '--show-current').strip()


def parent_of(branchline):
  parts = branchline.split()
  if parts[0] == '*':
    parts = parts[1:]
  branch_name = parts[0]
  commit_hash = parts[1]
  probably_parent = 'master'
  if parts[2].startswith('['):
    probably_parent = parts[2]
  if probably_parent.endswith(':') or probably_parent.endswith(']'):
    probably_parent = probably_parent[1:-1]
  else:
    probably_parent = 'master'
  return branch_name.strip(), probably_parent.strip()


class Branch(collections.namedtuple('Branch', ['name', 'children'])):
  def __hash__(self):
    return hash(self.name)

  def add(self, branch):
    self.children.append(branch)

  def flatten(self):
    for child in self.children:
      yield child.name

    for child in self.children:
      yield from child.flatten()


def parse_tree_for(name):
  branchtext = run('git', 'branch', '-vv')
  branches = []
  for line in branchtext.split('\n'):
    if line.strip():
      branches.append(parent_of(line.strip()))
  by_name = {}
  for branch, parent in branches:
    if branch not in by_name:
      by_name[branch] = Branch(branch, [])
    if parent not in by_name:
      by_name[parent] = Branch(parent, [])
    by_name[parent].add(by_name[branch])

  return by_name.get(name, None)


def rebase_subtree():
  tree = parse_tree_for(CURRENT)
  if not tree:
    print('Not in a git repository')
    return
  for branch in tree.flatten():
    print(run('git', 'checkout', branch))
    print(run('git', 'rebase'))
    usr = 'N'
    while usr not in ('Y', 'y', 'yes', 'Yes'):
      usr = input('Rebase finishes? [y/N]: ')
  run('git', 'checkout', CURRENT)


def main():
  DEBUG = True
  rebase_subtree()


if __name__ == '__main__':
  main()